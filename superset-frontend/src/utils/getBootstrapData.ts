/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

import { logging } from '@superset-ui/core';
import { BootstrapData } from 'src/types/bootstrapTypes';
import { DEFAULT_BOOTSTRAP_DATA } from 'src/constants';

/**
 * Unescapes common HTML entities found in HTML attributes.
 * This handles cases where the data-bootstrap attribute contains escaped characters.
 */
function unescapeHtmlAttribute(value: string): string {
  return value
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    .replace(/&amp;/g, '&')
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>');
}

/**
 * Converts Python-style dict notation (single quotes) to valid JSON (double quotes).
 *
 * This function handles the conversion character-by-character to properly:
 * - Convert string delimiters from single quotes to double quotes
 * - Preserve apostrophes within strings (e.g., "Don't" remains valid)
 * - Escape double quotes that appear inside originally single-quoted strings
 * - Maintain the structure of nested objects and arrays
 *
 * @param pythonStyleData - String with Python-style single-quoted dict notation
 * @returns JSON-compatible string with double quotes
 */
function convertPythonStyleToJson(pythonStyleData: string): string {
  let jsonCompatible = '';
  let inString = false;
  let stringChar = '';
  let escaped = false;

  for (let i = 0; i < pythonStyleData.length; i += 1) {
    const char = pythonStyleData[i];
    const nextChar =
      i < pythonStyleData.length - 1 ? pythonStyleData[i + 1] : '';
    const prevChar = i > 0 ? pythonStyleData[i - 1] : '';

    // Handle escape sequences
    if (escaped) {
      jsonCompatible += char;
      escaped = false;
      // eslint-disable-next-line no-continue
      continue;
    }

    if (char === '\\') {
      jsonCompatible += char;
      escaped = true;
      // eslint-disable-next-line no-continue
      continue;
    }

    // Handle string delimiters
    if ((char === "'" || char === '"') && !escaped) {
      if (!inString) {
        // Starting a string
        inString = true;
        stringChar = char;
        // Always use double quotes in output
        jsonCompatible += '"';
      } else if (char === stringChar) {
        // Potentially ending a string - but check if it's an apostrophe first
        // Heuristic: if we're in a single-quoted string and the next char is a letter,
        // it's probably an apostrophe (like "Don't"), not a closing quote
        const isLikelyApostrophe =
          stringChar === "'" &&
          /[a-zA-Z]/.test(nextChar) &&
          /[a-zA-Z]/.test(prevChar);

        if (isLikelyApostrophe) {
          // It's an apostrophe inside the string - just keep it as is
          // No need to escape since we're converting to double quotes
          jsonCompatible += "'";
        } else {
          // Ending a string
          inString = false;
          stringChar = '';
          // Always use double quotes in output
          jsonCompatible += '"';
        }
      } else if (stringChar === "'" && char === '"') {
        // It's a double quote inside what was a single-quoted string - escape it
        jsonCompatible += '\\"';
      } else {
        // It's a quote character inside a string delimited by a different quote
        jsonCompatible += char;
      }
    } else {
      jsonCompatible += char;
    }
  }

  return jsonCompatible;
}

/**
 * Attempts to parse bootstrap data with fallback for non-standard JSON formats.
 *
 * Issue: In embedded dashboards, sometimes the data-bootstrap attribute contains
 * Python-style dict notation (single quotes) instead of valid JSON (double quotes).
 * This can happen when the HTML is generated by templates that don't properly
 * serialize Python dicts to JSON.
 *
 * This function implements a tolerant parser that:
 * 1. First attempts strict JSON.parse
 * 2. Falls back to evaluating JavaScript object literals (for single-quoted strings)
 * 3. Logs warnings when non-standard format is detected
 *
 * SECURITY NOTE: The fallback uses Function constructor which is safe here because:
 * - The source is always the server-generated data-bootstrap attribute
 * - This is same-origin trusted content from Superset backend
 * - Never use this pattern with user-supplied or untrusted data
 */
function parseBootstrapData(rawData: string): BootstrapData {
  // Unescape HTML entities that might be present in the attribute
  const unescapedData = unescapeHtmlAttribute(rawData);

  // First, try standard JSON parsing
  try {
    const parsedData = JSON.parse(unescapedData);
    logging.info('[Superset] Bootstrap data successfully parsed as valid JSON');
    return parsedData;
  } catch (strictError) {
    logging.info(
      '[Superset] Strict JSON parsing failed, attempting fallback...',
    );
    // Check if this looks like a Python-style dict (single quotes)
    const isPythonLike =
      /^\s*{\s*'/.test(unescapedData) ||
      /':\s*(?:'|\{|\[|\d|true|false|null)/.test(unescapedData);

    if (!isPythonLike) {
      // Not Python-like, throw original error
      logging.error('[Superset] Invalid bootstrap data format:', strictError);
      throw strictError;
    }

    try {
      // Fallback: Convert Python-style single quotes to JSON double quotes
      const jsonCompatible = convertPythonStyleToJson(unescapedData);
      const parsedData = JSON.parse(jsonCompatible);

      logging.info(
        '[Superset] Bootstrap data successfully parsed using fallback parser (converted Python-style to JSON)',
      );

      // Warn in development to help identify the root cause
      if (process.env.NODE_ENV !== 'production') {
        logging.warn(
          '[Superset] Bootstrap data contains non-standard JSON format (Python-style dict with single quotes). ' +
            'This should be fixed on the server side by using json.dumps() instead of str(dict). ' +
            'The parser is using a tolerant fallback.',
        );
      }

      return parsedData as BootstrapData;
    } catch (fallbackError) {
      // Both parsers failed, log details and throw original error
      logging.error(
        '[Superset] Failed to parse bootstrap data with both strict and fallback parsers.',
        '\nOriginal error:',
        strictError,
        '\nFallback error:',
        fallbackError,
        '\nData preview:',
        unescapedData.substring(0, 200),
      );
      throw strictError;
    }
  }
}

export default function getBootstrapData(): BootstrapData {
  const appContainer = document.getElementById('app');
  const dataBootstrap = appContainer?.getAttribute('data-bootstrap');

  if (!dataBootstrap) {
    return DEFAULT_BOOTSTRAP_DATA;
  }

  try {
    return parseBootstrapData(dataBootstrap);
  } catch (error) {
    logging.error(
      '[Superset] Failed to load bootstrap data, using defaults:',
      error,
    );
    return DEFAULT_BOOTSTRAP_DATA;
  }
}
